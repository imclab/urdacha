<!doctype html>
<html lang='en'>
<head>
<title></title>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
</head>
<body>

<script src='http://mrdoob.github.com/three.js/examples/js/Detector.js'></script>
<script src='http://mrdoob.github.com/three.js/build/three.min.js'></script>
<script src='http://mrdoob.github.com/three.js/examples/js/controls/TrackballControls.js'></script>
<script src='http://mrdoob.github.com/three.js/examples/js/libs/stats.min.js'></script>
<!--
<script src='../../three.js/examples/js/Detector.js'></script>
<script src='../../three.js/build/three.min.js'></script>
<script src='../../three.js/examples/js/controls/TrackballControls.js'></script>
<script src='../../three.js/examples/js/libs/stats.min.js'></script>
-->
<script src='sidebars.js'></script>
<script>
	if ( ! Detector.webgl ) { Detector.addGetWebGLMessage(); }

	var xCoords, xKeys, xDelta;
	var yCoords, yDelta;
	var zCoords, zDelta;
	var keys;
	var data; 
	var dataPlay = false;

	init();
	animate();

	function readHash() {
		if ( location.hash == '' ) {
			initCity( 1, 1 );
		} else {
			var item;
			var a = location.hash.split('#');
			for (var i = 1, len = a.length; i < len; i++) {
				item = a[i].split('=');
				HAX[item[0]] = item[1];
			}	
			initCity( HAX.cityId, HAX.fieldsId );
		}
	}	

	function buildHash() {
		if (HAX.upX === undefined) return;
		var h = HAX;
		var link = 
			'camType=' + h.camType + '#camFov=' + h.camFov +
			'#camX=' + h.camX.toFixed(2) + '#camY=' + h.camY.toFixed(2) + '#camZ=' + h.camZ.toFixed(2) +
			'#cityId=' + h.cityId +
			'#colorField=' + h.colorField + 
			'#direction=' + h.direction + 
			'#directionString=' + h.directionString +
			'#fieldsId=' + h.fieldsId +
			'#folder=' + h.folder + '#fname=' + h.fname + 
			'#rotX=' + h.rotX.toFixed(3) + '#rotY=' + h.rotY.toFixed(3) + '#rotZ=' + h.rotZ.toFixed(3) +
			'#objCount=' + h.objCount +
			'#speed=' + h.speed +
			'#time=' + h.time + 
			'#title=' + h.title +
			'#trailCount=' + h.trailCount +
			'#trailLength=' + h.trailLength +
			'#tralEnd=' + h.trailEnd +	
			'#trailStart=' + h.trailStart + 
			'#upX=' + parseFloat(h.upX).toFixed(3) + '#upY=' + parseFloat(h.upY).toFixed(3) + '#upZ=' + parseFloat(h.upZ).toFixed(3) +	 
			'#x=' + h.x +  '#y=' + h.y + '#z=' + h.z + 		
		'';
		return link;
	}	
	
	function updateHash() {
		HAX.link = buildHash();
		permalink.href = "#" + HAX.link;
		window.location.hash = HAX.link;
	}
	
	function resetHash() {
		window.history.pushState( '', '', window.location.pathname);
		permalink.href = '';
		readHash();
	}

	function init() {
		
		readHash();
		
		if ( ! Detector.webgl ) {
			HAX.renderer = new THREE.Canvas.renderer( { antialias: true } );
		} else {
			HAX.renderer = new THREE.WebGLRenderer( { antialias: true } );
		}

		HAX.renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( HAX.renderer.domElement );
		HAX.scene = new THREE.Scene();
		
		HAX.camera = new THREE.PerspectiveCamera( HAX.camFov, window.innerWidth / window.innerHeight, 1, 1000 );
		HAX.camera.position.set( HAX.camX, HAX.camY, HAX.camZ);
		HAX.camera.up.set( HAX.upX, HAX.upY, HAX.upZ );
		HAX.camera.rotation.set( HAX.rotX, HAX.rotY, HAX.rotZ );
		HAX.controls = new THREE.TrackballControls( HAX.camera, HAX.renderer.domElement );
		HAX.controls.minDistance = 3;
		HAX.controls.maxDistance = 300;
		HAX.controls.noPan = true;
		HAX.controls.zoomSpeed = 0.5;
		HAX.controls.dynamicDampingFactor = 0.9;			

		var light = new THREE.DirectionalLight( 0xffffff, 2 );
		light.position.set( 1, 1, 1 ).normalize();
		HAX.scene.add( light );

		var light = new THREE.DirectionalLight( 0xffffff, 1.3 );
		light.position.set( -1, -1, -1 ).normalize();
		HAX.scene.add( light );

		var light = new THREE.AmbientLight( 0xffffff);
		light.color.setHSL( 0.1, 0.5, 0.3 );
		HAX.scene.add( light );
		
		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mouseup', onDocumentMouseUp, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );		

		initText(); // in sidebar.js
		
		HAX.stats = new Stats();
		HAX.stats.domElement.style.cssText = 'position: absolute;right: 0; top: 0px; z-index: 100; ';
		info.appendChild( HAX.stats.domElement );		
		
		// initObjects();
		toggleBar( info )
	}

	function initObjects() {
		var geometry = new THREE.CubeGeometry( 3, 3, 3 );
		var material = new THREE.MeshPhongMaterial( {color: 0xff0000, ambient: 0xffffff } );
		HAX.objects = [];
		var cube;
		for (var i = 0; i < HAX.objCount; i++) {
			cube = new THREE.Mesh( geometry, material );
			HAX.objects.push( cube );
			cube.position.set(100 * Math.random() - 50, 0, 0 ); // if they are all in the same place, really slows things down...
			HAX.scene.add( cube );
		}

		geometry = new THREE.Geometry();
		material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
		HAX.lines = [];
		var line;
		geometry.vertices.push(
			v( 0, 0, -50),
			v( 0, 0, 50)
		);		
		for (var i = 0; i < HAX.trailCount; i++) {
			line = new THREE.Line( geometry, material );
			HAX.lines.push( line );
			HAX.scene.add( line );
		}
	}

	function v( x, y, z) { return new THREE.Vector3( x, y, z ); }
	
	var xmlhttp, callbackCount;
	
	function loadCSV() {
		dataPlay = false;
		xmlhttp = new XMLHttpRequest();
		xmlhttp.open( 'GET', HAX.city.folder + HAX.city.fname, true );
		xmlhttp.onreadystatechange = callbackCSV;
		xmlhttp.send( null );
		callbackCount = 0;
	}
	
	function callbackCSV() {
		if ( xmlhttp.readyState == 4  ) {
			var dataLines = xmlhttp.responseText;
			dataLines = dataLines.split(/\r\n|\n/);
			dataLines[0] = dataLines[0].replace(/["']/g, ""); // delete in files
			dataLength = dataLines.length - 1;
			data = [];
			var sep = HAX.separator;
			for ( var i = 0; i < dataLength; i++ ) {
				data.push( dataLines[i].split( sep ) );
			}
			buildReport();
			
		} else {
			callbackCount++;
if (window.console) { console.log('waiting...'); }
			// If ( HAX.updates !== undefined) { HAX.updates.innerHTML = ' Responses from server (first time may need 20,000+): ' + callbackCount; }
		}
	}	

	function buildReport() {
		var h = HAX;
		h.dataLength = data.length;
		
		h.scene = new THREE.Scene();
		updateAxis();
		updateSidebar();
		
		xKeys = findSets( h.x );
		xDelta = 100 / xKeys.length;
		var txt = '<h3 style="color: red" >X-Axis - ' + xKeys.length + ' items</h3><table id="rd1" style="width: 100%;" >' +
			'<tr><td >' + data[0][h.x] + '<br><small><button onclick="sortTable( rd1, 0, 0)">&uArr;</button><button onclick="sortTable( rd1, 0, 1 )">&dArr;</button></small></td>' +
			'<td><small>tot:' + tots + ' avg:' + avg.toFixed(1) + '<br><button onclick="sortTable( rd1, 1, 0)">&uArr;</button><button onclick="sortTable( rd1, 1, 1 )">&dArr;</button></small></td></tr>';
		for (var i = 0, len = xKeys.length; i < len; i++) {
			txt += '<tr onclick="HAX.highlight=' + xKeys[i] + ';" ><td>' + xKeys[i] + '</td><td>' + sets[ xKeys[i] ].count + '</td></tr>';
		} 
		txt += '</table>';
		readout1.innerHTML = txt;

		yKeys = findSets( h.y );
		yDelta = 100 / yKeys.length;
		txt = '<h3 style="color: green" >Y-axis - ' + yKeys.length + ' items</h3><table id="rd2" style="width: 100%;" >' +
			'<tr><td>' + data[0][h.y] + '<br><small><button onclick="sortTable( rd2, 0, 0)">&uArr;</button><button onclick="sortTable( rd2, 0, 1 )">&dArr;</button></small></td>' +
			'<td><small>tot:' + tots + ' avg:' + avg.toFixed(1) + '<br><button onclick="sortTable( rd2, 1, 0)">&uArr;</button><button onclick="sortTable( rd2, 1, 1 )">&dArr;</button></small></td></tr>';
		for (var i = 0, len = yKeys.length; i < len; i++) {
			txt += '<tr onclick="HAX.highlight=' + yKeys[i] + ';"><td>' + yKeys[i] + '</td><td>' + sets[ yKeys[i] ].count + '</td></tr>';
		} 
		txt += '</table>';
		readout2.innerHTML = txt;

		zKeys = findSets( h.z );
		zDelta = 100 / zKeys.length;
		txt = '<h3 style="color: blue" >Z-axis - ' + zKeys.length + ' items</h3><table id="rd3" style="width: 100%;" >' +
			'<tr><td>' + data[0][h.z] + '<br><small><button onclick="sortTable( rd3, 0, 0)">&uArr;</button><button onclick="sortTable( rd3, 0, 1 )">&dArr;</button></small></td>' +
			'<td><small>tot:' + tots + ' avg:' + avg.toFixed(1) + '<br><button onclick="sortTable( rd3, 1, 0)">&uArr;</button><button onclick="sortTable( rd3, 1, 1 )">&dArr;</button></small></td></tr>';
		for (var i = 0, len = zKeys.length; i < len; i++) {
			txt += '<tr onclick="HAX.highlight=' + zKeys[i] + ';" ><td>' + zKeys[i] + '</td><td>' + sets[ zKeys[i] ].count+ '</td></tr>';
		} 
		txt += '</table>';
		readout3.innerHTML = txt;

		HAX.vehicles = {}
		HAX.vehicle = function() {
			this.id = null;
			this.obj = null;
			this.trail = null;
			this.trailPoints  = [];
			this.route = null;
		}
		
		HAX.colorsSet = findSets( HAX.colorField );
		HAX.colors = colorful(  HAX.colorsSet );
/*
		HAX.lineSets = {};
		HAX.lineSets.element = function() {
			this.points = [];
			this.subSet = null;
		}
		HAX.lineSetChanges = 0;
*/		
		HAX.objects = [];

// Let's roll...
		dataPlay = true;
	}

	var sets, tots, avg;
	function findSets( fieldId ) {
		sets = {};
		sets.element = function() {};
		for (var record, field, i = 1; i < dataLength; i++) {
			record = data[i];
			field = record[ fieldId ];
			if ( sets[ field ] == undefined ) {
				sets[ field ] = new sets.element;
				sets[ field ].count = 1;
			} else {
				sets[ field ].count++;
			}
		}
		delete sets['element'];
		var keys = Object.keys( sets );
		tots = 0;
		for (var i = 0, len = keys.length; i < len; i++) {
			tots += sets[keys[i]].count;
		} 
		avg = tots / keys.length;
		keys.sort( function(a,b){return a-b} )
		return keys;
	}
		var color, record, mesh, material, pos, line;	
		
	function haxisIt() {

		var h = HAX;
		var cyl = new THREE.CylinderGeometry( 2, 0, 4, 5 );
		
		for (var len = HAX.speed, i = 1; i < len; i++) {
			record = data[ HAX.dataCount ];
			var vehicleId = record[ h.vehNo ];
			color = HAX.colors[ HAX.colorsSet.indexOf( record[ h.colorField ] ) ];
			material = new THREE.MeshBasicMaterial( {color: 0xff0000, ambient: 0xffffff, opacity: 0.7, transparent: true } );
// direction
			if ( HAX.vehicles[vehicleId] == undefined ) {
				// color = HAX.colors[ HAX.colorsSet.indexOf( record[ h.colorField ] ) ];
				
				if (  HAX.highlight == record[ h.x ]  || HAX.highlight == record[ h.y ] || HAX.highlight == record[ h.z ]) {
					material.color.setHSL( 0, 0, 0 );
				} else {	
					material.color.setHSL( color, 0.8, 0.5 );
				}			
				
				HAX.vehicles[vehicleId] = new HAX.vehicle();
				HAX.vehicles[vehicleId].id = vehicleId;
				HAX.vehicles[vehicleId].obj =  new THREE.Mesh( cyl, material );
				HAX.objects.push( HAX.vehicles[vehicleId].obj );
				HAX.scene.add( HAX.vehicles[vehicleId].obj );
			}
			
			pos = v(  xDelta * xKeys.indexOf( record[ h.x] ) - 50, yDelta * yKeys.indexOf( record[ h.y] ) - 50, zDelta * zKeys.indexOf( record[ h.z] ) - 50 );
			HAX.vehicles[vehicleId].obj.position = pos ;
			HAX.vehicles[vehicleId].obj.record = record;
			HAX.vehicles[vehicleId].trailPoints.push( pos );
			
			if ( record[ h.direction ] === h.directionString ) {
// console.log( record[ h.direction ],		h.directionString );
				HAX.vehicles[vehicleId].obj.rotation.z = 0;
			} else {
				HAX.vehicles[vehicleId].obj.rotation.z = Math.PI;
			}			
			
			if ( HAX.vehicles[vehicleId].trailPoints.length > HAX.trailLength ) HAX.vehicles[vehicleId].trailPoints.shift(); 
			geometry = new THREE.Geometry();
			material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
			material.color.setHSL( color, 0.8, 0.5 );

			geometry.vertices = HAX.vehicles[vehicleId].trailPoints;
			HAX.scene.remove( HAX.vehicles[vehicleId].trail );
			HAX.vehicles[vehicleId].trail = new THREE.Line( geometry, material );
			HAX.scene.add( HAX.vehicles[vehicleId].trail );
			
/*
			item = HAX.objects.shift();
			HAX.scene.remove( item );

			mesh = new THREE.Mesh( cyl, material );
			// cube.material.color.setHSL( color, 0.8, 0.5 );
			pos = v( xDelta * xKeys.indexOf( record[ h.x] ) - 50, yDelta * yKeys.indexOf( record[ h.y] ) - 50, zDelta * zKeys.indexOf( record[ h.z] ) - 50 );

			mesh.position = pos ;
			mesh.record = record;
			HAX.objects.push( mesh );
			HAX.scene.add( mesh );

			var element = record[ h.trailStart ];
			if ( HAX.lineSets[element] == undefined ) {
				HAX.lineSets[element] = new HAX.lineSets.element();
				HAX.lineSets[element].lineSubSet = record[ h.trailEnd ];
			}
			if ( HAX.lineSets[element].lineSubSet != record[ h.trailEnd ] ) {
				HAX.lineSets[element].points.shift();
				HAX.lineSets[element].points = [];
// console.log( dataCount, HAX.lineSets[element].lineSubSet, record[ HAX.trailEnd ] );
				HAX.lineSetChanges++;
			} else if( HAX.lineSets[element].points.length > HAX.trailLength ) {
				HAX.lineSets[element].points.shift();
			}
			HAX.lineSets[element].points.push( pos );

			item = HAX.lines.shift();
			
			HAX.scene.remove( item );

			geometry = new THREE.Geometry();
			material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
			material.color.setHSL( color, 0.8, 0.5 );

			geometry.vertices = HAX.lineSets[element].points;
			line = new THREE.Line( geometry, material );
			HAX.lines.push(line );
			HAX.scene.add( line );
*/
			HAX.dataCount++;
		}
		
		stats.innerHTML = 'City: ' + h.title + '<br>' +
			'Total lines in file: ' + HAX.dataLength + '<br>' +
			'Current line: ' + HAX.dataCount + '<br>' +
			// 'Day: ' + record[ h.date] + ' Time: ' + record[ h.time] + '<br>' +
			'Time: ' + record[ h.time] + '<br>' +
			'Replay speed: ' + HAX.speed + '<br>' +
			'Camera FOV: ' + HAX.camFov + '<br>' +
			'X: ' + data[0][ h.x] + ': ' + xKeys.length +  '<br>' +
			'Y: ' + data[0][ h.y] + ': ' + yKeys.length + '<br>' +
			'Z: ' + data[0][ h.z] + ': ' + zKeys.length + '<br>' +
			// 'Lines disconnected: ' + HAX.lineSetChanges +
		'';
		
		if ( HAX.dataCount > HAX.dataLength - HAX.speed - 1 ) { 
			HAX.dataCount = 1; 
			HAX.lineSetChanges = 0;
			for ( var veh in HAX.vehicles ) {
// console.log (veh );			
				HAX.vehicles[veh].obj.position.set( -50, -50,-50 );
				HAX.scene.remove( HAX.vehicles[veh].trail );
				HAX.vehicles[veh].trailPoints = [];
			}
		}
	}

	function animate() {
		requestAnimationFrame( animate );
		HAX.controls.update();
		HAX.renderer.render( HAX.scene, HAX.camera );
		if ( dataPlay === true ) {
			haxisIt();
		}
		HAX.stats.update();
	}

	function togglePlay() {
		if (data === undefined) return; 
		if ( dataPlay === true ) {
			dataPlay = false ;
		} else {
			dataPlay = true;
		}
	}

	function colorful( arr ) {
		var delta = 1.0 / arr.length;
		var colList = [];
		for ( var i = 0, len = arr.length; i < len; i++ ) {
			colList.push( i *  delta );
		}
		return colList;
	}

	function updateAxis( ) {
		var h = HAX;
		geometry = new THREE.PlaneGeometry( 100, 20, 1, 1 );

		material = canvasText( data[0][h.x] , { color: '#ff0000', fontSize: '48', height: 80,  width: 600 }  );
		var sign = new THREE.Mesh( geometry, material );
		sign.rotation.set( -1.5708, 0, 0);
		sign.position.set( 0, -50, -60);
		HAX.scene.add( sign );

		material = canvasText( data[0][h.y] , { color: '#00ff00', fontSize: '48', height: 80, width: 600 }  );
		sign = new THREE.Mesh( geometry, material );
		sign.rotation.set( 0,0 , -1.5708);
		sign.position.set( -60, -15, -50);
		HAX.scene.add( sign );

		material = canvasText( data[0][h.z] , { color: '#0000ff', fontSize: '48', height: 80,  width: 600 }  );
		sign = new THREE.Mesh( geometry, material );
		sign.rotation.set( -1.5708,0 , -1.5708);
		sign.position.set( -60, -50, 0);
		HAX.scene.add( sign );

		sign = new THREE.AxisHelper( 100 );
		sign.position.set( -50, -50, -50 );
		HAX.scene.add( sign );
		
		sign = new THREE.AxisHelper( 100 );
		sign.position.set( 50, 50, 50 );
		sign.scale.set(-1,-1,-1);
		HAX.scene.add( sign );
	}

	function canvasText ( text1, parameters ) {
		canvas = document.createElement("canvas");
		var width = ( parameters['width'] ) ? parameters['width'] : 300 ;
		canvas.width = width;
		var height = ( parameters['height'] ) ? parameters['height'] : 150 ;
		canvas.height = height;

		context = canvas.getContext("2d");
		context.fillStyle =  ( parameters['backgroundColor'] !== undefined ) ? parameters['backgroundColor'] : 'transparent';
		context.fillRect( 0, 0, width, height );
		//context.lineWidth = 2;
		//context.strokeRect(0, 0, width, height);
		context.fillStyle = ( parameters['color']) ? parameters['color'] : '#ffffff';

		context.font = ( parameters['fontSize'] !== undefined ) ? parameters['fontSize'] + "pt Arial bold" : '16pt Arial bold';
		context.textAlign = ( parameters['textAlign'] ) ? parameters['textAlign'] : 'left' ;
		context.textBaseline = "top";
		context.fillText(text1, 5, 0);

		map = new THREE.Texture( canvas );
		map.needsUpdate = true;
		return new THREE.MeshBasicMaterial( { map: map,  side: THREE.DoubleSide, transparent: true } );
	}

	function onWindowResize() {
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;
		HAX.camera.aspect = window.innerWidth / window.innerHeight;
		HAX.camera.updateProjectionMatrix();
		HAX.renderer.setSize( window.innerWidth, window.innerHeight );
	}
	
	function onDocumentMouseUp() {
		if ( HAX.objects == undefined ) return;
		var h = HAX;
		var c = HAX.camera;
		h.camX = c.position.x; h.camY = c.position.y; h.camZ = c.position.z;
		h.rotX = c.rotation.x; h.rotY = c.rotation.y; h.rotZ = c.rotation.z;
		h.upX = c.up.x; h.upY = c.up.y; h.upZ = c.up.z;
		
		updateHash();
	}	
		var intersected;
	function onDocumentMouseMove( event ) {
		if ( data == undefined ) return;
		// event.preventDefault();
		var mouse = { x: -1, y: -1 };
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;		
		var projector = new THREE.Projector();
		var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
		projector.unprojectVector( vector, HAX.camera );
		var raycaster = new THREE.Raycaster( HAX.camera.position, vector.sub( HAX.camera.position ).normalize() );
		var intersects = raycaster.intersectObjects( HAX.objects );

		if ( intersects.length > 0 ) {
			if ( intersected != intersects[ 0 ].object ) { // not same one
				intersected = intersects[ 0 ].object;
			}
			headsUp.style.left = 10 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
			headsUp.style.bottom = 10 + 0.5 * window.innerHeight + mouse.y * 0.5 * window.innerHeight+ 'px';
			headsUp.style.display = '';
			var h = HAX, ir = intersected.record, txt = '';
			headsUp.innerHTML =  
				'X: ' + data[0][ h.x] + ' ' + ir[ h.x] + '<br>' +
				'Y: ' + data[0][ h.y] + ' ' + ir[ h.y] + '<br>' +
				'Z: ' + data[0][ h.z] + ' ' + ir[ h.z] + '<br>' +
				'Number of identical events: ' + intersects.length + '<br>';
				
			for (var i = 0, len = ir.length; i < len; i++) {
				txt += data[0][ i] + ':' + ir[i] + '<br>';
			}
			headsUp.innerHTML += '<div style="column-count: 2; font-size:small; word-wrap:break-word; ">' + txt + '</div>';
				//'<br>All the data [for testing]: <br>' +
				//intersected.record;
		} else {
			headsUp.style.display = 'none';
		}
	}
</script>
</body>
</html>